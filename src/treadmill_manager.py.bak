#!/usr/bin/env python
from bleak import BleakClient
import asyncio
import struct
import yaml
import os
import logging
import time
from pathlib import Path
from typing import Optional, Callable, Dict, Any

class WoodwayTreadmill:
    """Robust treadmill manager with guaranteed shutdown capability."""
    
    def __init__(self, config_path: str = None):
        # Initialize logger first
        self.logger = logging.getLogger('WoodwayTreadmill')
        self.logger.setLevel(logging.DEBUG)
        
        # Config path resolution
        if config_path is None:
            config_path = str(Path(__file__).parent.parent / 'configs' / 'woodway_treadmill.yaml')
        
        self.config = self._load_config(config_path)
        self.client = None
        self._callback = None
        self.is_connected = False
        self._lock = asyncio.Lock()
        self._shutdown_flag = False
        self.address = self.config['address'].upper()
        self._last_data_time = None
        self._data_timeout = 15.0
        self.speed = None
        self.incline = None

    def _load_config(self, path: str) -> Dict[str, Any]:
        """Load and validate configuration file."""
        try:
            with open(path) as f:
                config = yaml.safe_load(f)
            
            required_keys = {'address', 'data_uuid', 'byte_positions', 'scale_factors'}
            if missing := required_keys - set(config.keys()):
                raise ValueError(f"Missing config keys: {missing}")
            
            return config
        except Exception as e:
            self.logger.critical(f"Config error: {str(e)}")
            raise

    async def connect(self, retries: int = 3) -> None:
        """Establish connection with automatic retries."""
        async with self._lock:
            for attempt in range(1, retries + 1):
                if self._shutdown_flag:
                    return
                    
                try:
                    self.logger.info(f"Connection attempt {attempt}/{retries}")
                    self.client = BleakClient(self.address, timeout=20.0)
                    await self.client.connect()
                    await self._enable_notifications()
                    
                    self.is_connected = True
                    self._last_data_time = time.time()
                    self.logger.info("Connected successfully")
                    return
                    
                except Exception as e:
                    self.logger.error(f"Attempt {attempt} failed: {str(e)}")
                    await self._cleanup_connection()
                    if attempt == retries:
                        raise
                    await asyncio.sleep(2 ** attempt)

    async def _enable_notifications(self):
        """Enable data notifications."""
        try:
            await self.client.start_notify(
                self.config['data_uuid'],
                self._notification_handler
            )
        except Exception as e:
            self.logger.error(f"Notification error: {str(e)}")
            raise

    def _handle_disconnect(self, client):
        """Handle unexpected disconnections."""
        if not self._shutdown_flag:
            self.logger.warning("Device disconnected")
            asyncio.create_task(self._auto_reconnect())

    async def _auto_reconnect(self):
        """Automatic reconnection handler."""
        while not self.is_connected and not self._shutdown_flag:
            try:
                await self.connect()
                if self.is_connected:
                    return
                await asyncio.sleep(5)
            except Exception as e:
                self.logger.error(f"Reconnect failed: {str(e)}")
                await asyncio.sleep(5)

    def _parse_data(self, data: bytearray) -> Dict[str, Any]:
        """Parse and validate incoming data."""
        result = {}
        try:
            if 'speed' in self.config['byte_positions']:
                pos = self.config['byte_positions']['speed']
                if len(data) >= pos[1] + 1:
                    raw = struct.unpack("<H", data[pos[0]:pos[1]+1])[0]
                    result['speed'] = raw / self.config['scale_factors']['speed']

            if 'incline' in self.config['byte_positions']:
                pos = self.config['byte_positions']['incline']
                if len(data) >= pos[1] + 1:
                    raw = struct.unpack("<H", data[pos[0]:pos[1]+1])[0]
                    result['incline'] = raw / self.config['scale_factors']['incline']
        except Exception as e:
            self.logger.error(f"Parse error: {str(e)}")
        return result

    def _notification_handler(self, char, data: bytearray):
        """Process incoming data."""
        self._last_data_time = time.time()
        parsed = self._parse_data(data)
        if parsed:
            self.speed = parsed.get('speed')
            self.incline = parsed.get('incline')
            if self._callback:
                try:
                    self._callback(parsed)
                except Exception as e:
                    self.logger.error(f"Callback error: {str(e)}")

    async def _cleanup_connection(self):
        """Atomic cleanup operation."""
        try:
            if self.client and self.client.is_connected:
                await self.client.stop_notify(self.config['data_uuid'])
                await self.client.disconnect()
        except Exception as e:
            self.logger.warning(f"Cleanup warning: {str(e)}")
        finally:
            self.is_connected = False
            self.client = None

    async def disconnect(self):
        """Foolproof shutdown that always works."""
        self._shutdown_flag = True
        
        try:
            # Normal shutdown with timeout
            await asyncio.wait_for(
                self._cleanup_connection(),
                timeout=5.0
            )
        except asyncio.TimeoutError:
            # Nuclear option if stuck
            self.logger.critical("FORCING DISCONNECT")
            if hasattr(self.client, '_backend'):
                self.client._backend._disconnect()
        finally:
            self.logger.info("Disconnect completed")

    @property
    def callback(self) -> Optional[Callable]:
        return self._callback
        
    @callback.setter
    def callback(self, func: Callable[[Dict[str, Any]], None]):
        self._callback = func